1. Dada uma variável `a` do tipo `char` (um byte), escreva os trechos de código em C para:
	(a) Somente setar o bit menos significativo de `a`.
		P1 DIR &= BIT0;
		
	(b) Somente setar dois bits de `a`: o menos significativo e o segundo menos significativo.
		P1 DIR &= BIT0 + BIT1;
		
	(c) Somente zerar o terceiro bit menos significativo de `a`.
		PI DIR &= ~BIT2;
		
	(d) Somente zerar o terceiro e o quarto bits menos significativo de `a`.
		P1 DIR &= ~(BIT2 + BIT3);
		
	(e) Somente inverter o bit mais significativo de `a`.
		PI DIR ^= BIT7;
		
	(f) Inverter o nibble mais significativo de `a`, e setar o nibble menos significativo de `a`. 
		P1 DIR ^= (BIT7 + BIT6 + BIT5 + BIT4);
		P1 DIR &= BIT0;

2. Considerando a placa Launchpad do MSP430, escreva o código em C para piscar os dois LEDs ininterruptamente.
	#include <msp430g2553.h>
	#define LED1 BIT0
	#define LED2 BIT6
	#define LEDS (LED1|LED2)
	#define BTN  BIT3

	int main(void)
	{
		WDTCTL = WDTPW | WDTHOLD;
		P1OUT |= LEDS;
		P1DIR |= LEDS;
		while(1);
		return 0;
	}

3. Considerando a placa Launchpad do MSP430, escreva o código em C para piscar duas vezes os dois LEDs sempre que o usuário pressionar o botão.
	#include <msp430g2553.h>
	#include <legacymsp430.h> // Para rodar interrupcoes
	#define LED1 BIT0
	#define LED2 BIT6
	#define LEDS (LED1|LED2)
	#define BTN  BIT3

	void atraso(volatile unsigned int i)
	{
		while((i--)>0);
	}

	int main(void)
	{
		WDTCTL = WDTPW | WDTHOLD;
		P1OUT |= LEDS;
		P1DIR |= LEDS;
		P1DIR &= ~BTN;
		P1REN |= BTN;
		P1OUT |= BTN;
		P1IES |= BTN;
		P1IE |= BTN;
		_BIS_SR(GIE);
		while(1)
		{
			atraso(0xFFFF);
			P1OUT ^= LEDS;
		}
		return 0;
	}

	interrupt(PORT1_VECTOR) Interrupcao_P1(void)
	{
		while((P1IN&BTN)==0);
		P1IFG &= ~BTN;
	}

4. Considerando a placa Launchpad do MSP430, faça uma função em C que pisca os dois LEDs uma vez.

5. Reescreva o código da questão 2 usando a função da questão 4.

6. Reescreva o código da questão 3 usando a função da questão 4.







#define BITOP(a,b,op) \
 ((a)[(size_t)(b)/(8*sizeof *(a))] op (size_t)1<<((size_t)(b)%(8*sizeof *(a))))
// Sintaxe BITOP(v, pos, operacao)
// v = variavel que tera os bits manipulados, que sera tratada como um vetor
// pos = posicao bit dentro do vetor que voce deseja fazer algo
// operacao = operação que sera realizada sendo:
//            |= para setar o bit
//            ^= mudar o valor do bit
//            &  testar o bit (sendo que o retorno é 0, caso o bit for 0
//                                                   2^pos, caso o bit for 1)
//            &=~ limpar os bits
// BITOP retorna um long int


1. Dada uma variável 'a' do tipo 'char' (um byte), escreva os trechos de código em C para:
	(a) Somente setar o bit menos significativo de 'a'.
	
	BITOP(&c, a, |=); // setei o bit a
	printf("%d\n", c);

	
	(b) Somente setar dois bits de 'a': o menos significativo e o segundo menos significativo.
	BITOP(&c, a, |=); 
	BITOP(&c, a+1, |=); 
	
	
	(c) Somente zerar o terceiro bit menos significativo de 'a'.

	BITOP(&c, a+3, &=~); 
	
	
	(d) Somente zerar o terceiro e o quarto bits menos significativo de 'a'.
	BITOP(&c, a+3, &=~); 
	
	
	(e) Somente inverter o bit mais significativo de 'a'.
	printf("%d\n", c);

	printf("%ld\n", BITOP(&c, 2, &)); // testandoo bit 2
	
	printf("%ld\n", BITOP(&c, 5, &)); // testandoo bit 5


	BITOP(&c, 2, ^=); // mudei o bit 2
	printf("%d\n", c);
	
	(f) Inverter o nibble mais significativo de 'a', e setar o nibble menos significativo de 'a'.
	

2. Considerando a placa Launchpad do MSP430, escreva o código em C para piscar os dois LEDs ininterruptamente.

3. Considerando a placa Launchpad do MSP430, escreva o código em C para piscar duas vezes os dois LEDs sempre que o usuário pressionar o botão.

4. Considerando a placa Launchpad do MSP430, faça uma função em C que pisca os dois LEDs uma vez.

5. Reescreva o código da questão 2 usando a função da questão 4.

6. Reescreva o código da questão 3 usando a função da questão 4.
